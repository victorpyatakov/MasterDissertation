close all;
clear all;
clc;
conditional_prob=[0.991688773012421 0.991451726728436 0.991282477324199;0.00831122698757870 0.950520833333333 0.968169761273210;0 0.00854827327156419 0.951837769328264;0 0.0494791666666667 0.926829268292683;0 0 0.00871752267580148;0 0 0.0318302387267905;0 0 0.0481622306717364;0 0 0.0731707317073171];

%% переменные для генератора, n1.n2..nM=разряды генератора в 8чном виде,   g состояние гератора , n-количество выходных бит
   n1=7;n2=5; %k=2 R=1/2
   d = oct2dec([n1 ; n2]);%из 8 в 10 r=1/2
%       d = oct2dec([n1 ; n2;n3]);%из 8 в 10 r=1/3
    g =de2bi(d);%из 10 в 2
    n=2;
    k=2;% количество ячеек памяти в регистре
    reg=zeros(1,k+1); %регистр
    c=zeros(1,n);%выход сверточного кодера 
    z=10;
    L=z*k;%глубина просмотра решетки
    
     R=1/2;%скорость кода
     %% локальные переменные для канала

   SNRdBinit =15;    % начальное значение отношения сигнал/шум
   SNRdBfin  =30;    % конечное значение отношения сигнал/шум
   SNRdBincr =1;
%    nerr=0;%начальное значение количества ошибок
   NerrMax=100;%максимальное количество ошибок
  % Pe_theor = zeros(size(SNRdBinit : SNRdBincr : SNRdBfin));%массив для теор.вер.ошибки на бит
   Pe = zeros(size(SNRdBinit:SNRdBincr:SNRdBfin));%массиы для практ.вер.ошибки на бит
 
   %% подсчет меток ребер и соотвествие меток с состояниями ребер
 
     sost_metk  = sostoyanie_metok_reber( k,n,g );%подумать над этим
     
                                 %% МОДЕЛИРОВАНИЕ
    count=1;  %счетчик для вывода графиков  
    
    for SNRdB = SNRdBinit : SNRdBincr : SNRdBfin 
    %% Локальные переменные для декодера ВИтерби
     
     
     SNR =R* 10^(SNRdB/10); %перевод в децибелы отношение сигнал/шум
     U=ones(1,L)*5;% массив для хранение бит которые пришли на вход сверт.кодера
     takt=1;%такт передачи, 1 такт - это 1 входной бит и n выходных
    
    nerr=0;% обнуление количества ошибок для нового цикла по отношению сигнал/шум
    
    %% формирование массивов путей и накопленых меток
    
       [ path,path_new,metric,metric_new ] = path_and_metric( k,L );%подумать над этим
       
    exit_chanel=zeros(1,n);%mass for saving exit chanel
    p=0.9;% ро-коэффициент корреляции
     x=randn;
         y=randn;
    [ r0,r1,x,y ] = mod_chan_demodul2( 0,x,y,p,SNR );%вызов для настройки
    r=zeros(1,n);
    while nerr<NerrMax 
 %% источник сообщения
      
          input_bit=rand<0.5;%входной бит 0 или 1
          
             if takt>L
              old_b=U(1);
              U(1:end-1)=U(2:end);
              U(L)=input_bit;
             else
              U(1,takt)=input_bit;%мfссив для записи  что пришло на вход сверт.кодера
             end
             
             %% помехоустойчивый сверточный кодер

           [c,reg]  = ConvEncoder( input_bit,reg,g,n );% с =выходные биты 
           
           
           
           %% модулятор - канал- демодулятор нормированный выход

            for i=1:n
    
                a=c(1,i);
                       [ r0,r1,x,y ] = mod_chan_demodul2( a,x,y );
                
       if r1>r0
                      exit_chanel(1,i)=1;
                      
       else
                      exit_chanel(1,i)=0;
       end 
            end
            
                                        %% Помехоустойчивый декодер по алгоритму витерби
        
                            %изменит это            
       [ metric,path,b1 ] = vit_algoritm( k,L,sost_metk,exit_chanel,metric,path,takt,r,metric_new,path_new,conditional_prob );
        
          if takt>L
              
           if b1~=old_b
               nerr=nerr+1;
              
                disp([ SNRdB ,nerr , NerrMax, takt ]);
%                disp( toc );
           end
          end
          
        takt=takt+1;
        
%         if takt==3000000&&nerr==0
%             nerr=1;
%             break
%         end
%         
%         if mod(takt,1000000)==0
%              disp([ SNRdB , takt]);
%         end
        
    end
    
    %% подсчет вероятностей ошибок 
     Pe(count)=nerr/takt;         
%      Pe_theor(count)  = teor_P_bit( SNR,w,A_dfree );
    

%   Pe_1_res_0_30_snr= [0.322580645161290 0.334448160535117 0.299401197604790 0.294985250737463 0.270270270270270 0.235294117647059 0.274725274725275 0.259067357512953 0.161030595813205 0.151975683890578 0.141442715700141 0.106723585912487 0.0675675675675676 0.0589970501474926 0.0482625482625483 0.0237925291458482 0.0370919881305638 0.0101957585644372 0.00534644995722840 0.00394166338194718 0.00268182793391976 0.00132006230694089 0.000868432479374729 0.000544614848379226 0.000230790712058584 0.000133650530592606 8.25926834445444e-05 5.28983536974362e-05 2.71095426132189e-05 1.56115131162469e-05 9.66115433404214e-06];
    
    count=count+1;
    end                                      
         
           
           
          figure(1)

  semilogy(SNRdBinit:SNRdBincr:SNRdBfin, Pe,'r-o');
  
 title('Вероятость ошибки (результаты моделирования и теоретическая)', 'FontName', 'Arial Cyr', 'FontSize', 9)
 hx = xlabel('E/N_0, дБ');
 set(hx, 'FontName', 'Arial Cyr', 'FontSize', 9)
 hy = ylabel('P_e');
 set(hy, 'FontName', 'Arial Cyr', 'FontSize', 9)
 grid on    
           
           
     